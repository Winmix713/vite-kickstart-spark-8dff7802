import { supabase } from "@/integrations/supabase/client"; // Type definitions from Supabase schema name= Database['public']['Tables']['products'] extends { Row? R interface PlayerWithStats extends Player { stats) teamNames.set(match.away_team.id, { name.away_team.name, logo_url.away_team.logo_url, short_name.away_team.short_name }) teamForms.set(match.away_team.id, []) } // Update stats const homeStats = teamStats.get(match.home_team_id)! const awayStats = teamStats.get(match.away_team_id)! homeStats.played++ awayStats.played++ homeStats.goals_for += match.home_score || 0 homeStats.goals_against += match.away_score || 0 awayStats.goals_for += match.away_score || 0 awayStats.goals_against += match.home_score || 0 homeStats.goal_difference = homeStats.goals_for - homeStats.goals_against awayStats.goal_difference = awayStats.goals_for - awayStats.goals_against // Determine result and update form if ((match.home_score || 0) > (match.away_score || 0)) { homeStats.won++ awayStats.lost++ homeStats.points += 3 const homeForm = teamForms.get(match.home_team_id)! homeForm.unshift('W') homeForm.splice(5) const awayForm = teamForms.get(match.away_team_id)! awayForm.unshift('L') awayForm.splice(5) } else if ((match.home_score || 0) < (match.away_score || 0)) { homeStats.lost++ awayStats.won++ awayStats.points += 3 const homeForm = teamForms.get(match.home_team_id)! homeForm.unshift('L') homeForm.splice(5) const awayForm = teamForms.get(match.away_team_id)! awayForm.unshift('W') awayForm.splice(5) } else { homeStats.drawn++ awayStats.drawn++ homeStats.points++ awayStats.points++ const homeForm = teamForms.get(match.home_team_id)! homeForm.unshift('D') homeForm.splice(5) const awayForm = teamForms.get(match.away_team_id)! awayForm.unshift('D') awayForm.splice(5) } }) // Convert to final standings format const standings= Array.from(teamStats.entries()) .map(([teamId, stats], index) => ({ position+ 1, team, stats, form.get(teamId)!.join('') })) .sort((a, b) => { if (a.stats.points !== b.stats.points) return b.stats.points - a.stats.points if (a.stats.goal_difference !== b.stats.goal_difference) return b.stats.goal_difference - a.stats.goal_difference return b.stats.goals_for - a.stats.goals_for }) .map((standing, index) => ({ ...standing, position+ 1 })) return standings } catch (error) { console.error('Error fetching league standings:', error) throw error } }, // ===== LIVE MATCHES ===== async fetchLiveMatches()= await supabase .from('matches') .select(' *, home_team!matches_home_team_id_fkey(*), away_team!matches_away_team_id_fkey(*), league!matches_league_id_fkey(*) ') .eq('status', 'live') .order('match_date', { ascending) if (error) throw error return data || [] } catch (error) { console.error('Error fetching live matches:', error) throw error } }, // ===== FINISHED MATCHES ===== async fetchFinishedMatches(limit = 50)= await supabase .from('matches') .select(' *, home_team!matches_home_team_id_fkey(*), away_team!matches_away_team_id_fkey(*), league!matches_league_id_fkey(*) ') .eq('status', 'finished') .order('match_date', { ascending) .limit(limit) if (error) throw error return data || [] } catch (error) { console.error('Error fetching finished matches:', error) throw error } }, // ===== PLAYER PROFILE ===== async fetchPlayerProfile(playerId)= await supabase .from('players') .select('*') .eq('id', playerId) .single() if (error) { if (error.code === 'PGRST116') return null throw error } // Fetch player stats (you would need to create this table or calculate from matches) // For now, returning mock data structure const playerWithStats= { ...data, stats } return playerWithStats } catch (error) { console.error('Error fetching player profile:', error) throw error } }, // ===== STORE INVENTORY ===== async fetchStoreInventory(category?)= supabase .from('products') .select(' *, product_categories(*) ') if (category) { query = query.eq('product_categories.name', category) } const { data, error } = await query.order('name') if (error) throw error return (data || []).map(product => ({ id.id, name.name, description.description || '', price.price, category.product_categories, variants: [], // Would need to fetch from separate table images.images || [], inStock: (product.stock_quantity || 0) > 0, rating.rating || 0, reviews.review_count || 0 })) } catch (error) { console.error('Error fetching store inventory:', error) throw error } }, // ===== CHAT MESSAGES ===== async fetchChatMessages(conversationId?)= supabase .from('chat_messages') .select(' *, user(*) ') if (conversationId) { query = query.eq('conversation_id', conversationId) } const { data, error } = await query .order('created_at', { ascending) if (error) throw error return data || [] } catch (error) { console.error('Error fetching chat messages:', error) throw error } }, // ===== SCHEDULE ===== async fetchSchedule(type?: 'training' | 'match' | 'meeting' | 'event')= supabase .from('schedule') .select('*') if (type) { query = query.eq('type', type) } const { data, error } = await query .gte('date', new Date().toISOString()) .order('date', { ascending) if (error) throw error return (data || []).map(schedule => ({ id.id, title.title, type.type, date.date, duration.duration || 60, location.location || '', description.description || '', status.status })) } catch (error) { console.error('Error fetching schedule:', error) throw error } }, // ===== PREDICTIONS ===== async fetchPredictions(limit = 20)= await supabase .from('predictions') .select(' *, match( *, home_team!matches_home_team_id_fkey(*), away_team!matches_away_team_id_fkey(*), league!matches_league_id_fkey(*) ) ') .order('created_at', { ascending) .limit(limit) if (error) throw error return (data || []).map(prediction => ({ id.id, match, prediction, btts_prediction.btts_prediction, over_under_prediction }, model, factors.prediction_factors || { momentum: 0, home_advantage: 0, head_to_head: 0, form_rating: 0 }, status: 'pending', created_at.created_at })) } catch (error) { console.error('Error fetching predictions:', error) throw error } }, // ===== TODOS/TASKS ===== async fetchTodos(): 'low' | 'medium' | 'high' dueDate??= await supabase .from('todos') .select('*') .order('created_at', { ascending) if (error) throw error return (data || []).map(todo => ({ id.id, title.title, completed.completed, priority.priority || 'medium', dueDate.due_date, assignedTo.assigned_to })) } catch (error) { console.error('Error fetching todos:', error) throw error } }, // ===== SYSTEM STATUS ===== async fetchSystemStatus()= await supabase .from('system_health_metrics') .select('*') .order('timestamp', { ascending) .limit(1) .single() if (error) { // Return default status if no data return { health: 'healthy', uptime: 0, lastUpdated().toISOString(), metrics } } return { health.error_rate > 0.05 ? 'critical' .error_rate > 0.02 ? 'warning' : 'healthy', uptime: 0, // Would need to calculate from start time lastUpdated.timestamp, metrics } } catch (error) { console.error('Error fetching system status:', error) throw error } }, // ===== TEAM ANALYTICS ===== async fetchTeamAnalytics(teamId),away_team_id.eq.${teamId}') .eq('status', 'finished') .order('match_date', { ascending) .limit(10) if (matchesError) throw matchesError const { async data() { return await supabase .from('matches') .select(' *, home_team!matches_home_team_id_fkey(*), away_team!matches_away_team_id_fkey(*), league!matches_league_id_fkey(*) ') .or('home_team_id.eq.${teamId},away_team_id.eq.${teamId}`) .in('status', ['scheduled', 'live']) .order('match_date', { ascending) .limit(5) if (upcomingError) throw upcomingError // Calculate stats let wins = 0, draws = 0, losses = 0 let goalsFor = 0, goalsAgainst = 0, cleanSheets = 0 const recentForm= [] matches?.forEach(match => { const isHome = match.home_team_id === teamId const teamScore = isHome ? (match.home_score || 0) : (match.away_score || 0) const oppScore = isHome ? (match.away_score || 0) : (match.home_score || 0) goalsFor += teamScore goalsAgainst += oppScore if (teamScore > oppScore) { wins++ recentForm.unshift('W') } else if (teamScore === oppScore) { draws++ recentForm.unshift('D') } else { losses++ recentForm.unshift('L') } if (oppScore === 0) cleanSheets++ recentForm.splice(5) }) return { team, stats, recentForm, nextMatches(error) { console.error('Error fetching team analytics:', error) throw error } } } export default winmixApi
