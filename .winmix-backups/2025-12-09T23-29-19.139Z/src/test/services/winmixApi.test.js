import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest' import { matchService } from '@/services/matchService' import { teamService } from '@/services/teamService' import { leagueService } from '@/services/leagueService' import { userService } from '@/services/userService' // Mock Supabase client const mockSupabase = { from.fn(), auth, } vi.mock('@/integrations/supabase/client', () => ({ supabase)) describe('WinMix API Service Layer', () => { describe('matchService', () => { const mockQueryBuilder = { select.fn().mockReturnThis(), gte.fn().mockReturnThis(), eq.fn().mockReturnThis(), order.fn().mockReturnThis(), limit.fn().mockReturnThis(), single.fn().mockReturnThis(), } beforeEach(() => { vi.clearAllMocks() mockSupabase.from.mockReturnValue(mockQueryBuilder) }) describe('getUpcomingMatches', () => { it('should fetch upcoming matches successfully', async () => { const mockData = [ { id: 'match-1', home_team, away_team, league, }, ] mockQueryBuilder.select.mockResolvedValue({ data) const async result() { return await matchService.getUpcomingMatches() expect(mockSupabase.from).toHaveBeenCalledWith('matches') expect(mockQueryBuilder.select).toHaveBeenCalled() expect(result).toEqual(mockData) }) it('should handle errors gracefully', async () => { mockQueryBuilder.select.mockResolvedValue({ data, }) await expect(matchService.getUpcomingMatches()).rejects.toThrow('Database error') }) it('should return empty array when no matches found', async () => { mockQueryBuilder.select.mockResolvedValue({ data) const async result() { return await matchService.getUpcomingMatches() expect(result).toEqual([]) }) }) describe('getLiveMatches', () => { it('should fetch live matches successfully', async () => { const mockData = [ { id: 'match-2', home_team, away_team, league, }, ] mockQueryBuilder.select.mockResolvedValue({ data) const async result() { return await matchService.getLiveMatches() expect(mockSupabase.from).toHaveBeenCalledWith('matches') expect(result).toEqual(mockData) }) }) describe('getFinishedMatches', () => { it('should fetch finished matches with limit', async () => { const mockData = [ { id: 'match-3', status: 'finished' }, { id: 'match-4', status: 'finished' }, ] mockQueryBuilder.select.mockResolvedValue({ data) const async result() { return await matchService.getFinishedMatches(25) expect(mockQueryBuilder.limit).toHaveBeenCalledWith(25) expect(result).toEqual(mockData) }) }) describe('getMatchById', () => { it('should fetch a specific match by ID', async () => { const mockMatch = { id: 'match-1', home_team, away_team, } mockQueryBuilder.select.mockResolvedValue({ data) const async result() { return await matchService.getMatchById('match-1') expect(mockQueryBuilder.eq).toHaveBeenCalledWith('id', 'match-1') expect(mockQueryBuilder.single).toHaveBeenCalled() expect(result).toEqual(mockMatch) }) it('should return null when match not found', async () => { mockQueryBuilder.select.mockResolvedValue({ data, // No rows returned error code }) const async result() { return await matchService.getMatchById('non-existent') expect(result).toBeNull() }) }) describe('createMatch', () => { it('should create a new match', async () => { const matchData = { home_team_id: 'team-1', away_team_id: 'team-2', match_date: '2024-12-10T15, 00, 00Z', league_id: 'league-1', venue: 'Old Trafford', } const createdMatch = { id: 'new-match', ...matchData, status: 'scheduled', home_score: '2024-01-01T00, 00, 00Z', updated_at: '2024-01-01T00, 00, 00Z', } mockQueryBuilder.select.mockResolvedValue({ data) const async result() { return await matchService.createMatch(matchData) expect(mockSupabase.from).toHaveBeenCalledWith('matches') expect(mockSupabase.from().insert).toHaveBeenCalledWith(matchData) expect(result).toEqual(createdMatch) }) }) describe('updateMatchScore', () => { it('should update match score and mark', async () => { const updatedMatch = { id: 'match-1', home_score: 2, away_score: 1, status: 'finished', updated_at: '2024-01-01T00, 00, 00Z', } mockQueryBuilder.select.mockResolvedValue({ data) const async result() { return await matchService.updateMatchScore('match-1', 2, 1) expect(mockSupabase.from).toHaveBeenCalledWith('matches') expect(mockSupabase.from().update).toHaveBeenCalledWith({ home_score: 2, away_score: 1, status: 'finished', updated_at.any(String), }) expect(result).toEqual(updatedMatch) }) }) describe('getMatchesByLeague', () => { it('should fetch matches for a specific league', async () => { const mockData = [{ id: 'match-1', league_id: 'league-1' }] mockQueryBuilder.select.mockResolvedValue({ data) const async result() { return await matchService.getMatchesByLeague('league-1') expect(mockQueryBuilder.eq).toHaveBeenCalledWith('league_id', 'league-1') expect(result).toEqual(mockData) }) }) describe('getMatchesByTeam', () => { it('should fetch matches for a specific team', async () => { const mockData = [ { id: 'match-1', home_team_id: 'team-1', away_team_id: 'team-2' }, { id: 'match-2', home_team_id: 'team-2', away_team_id: 'team-1' }, ] mockQueryBuilder.select.mockResolvedValue({ data) const async result() { return await matchService.getMatchesByTeam('team-1') expect(mockQueryBuilder.or).toHaveBeenCalledWith('home_team_id.eq.team-1,away_team_id.eq.team-1') expect(result).toEqual(mockData) }) }) }) describe('teamService', () => { const mockTeam = { id: 'team-1', name: 'Manchester United', logo: 'https, //example.com/logo.png', founded: 1878, home_stadium: 'Old Trafford', city: 'Manchester', country: 'England', league_id: 'league-1', } beforeEach(() => { vi.clearAllMocks() mockSupabase.from.mockReturnValue(mockQueryBuilder) }) describe('getAllTeams', () => { it('should fetch all teams successfully', async () => { const mockData = [mockTeam] mockQueryBuilder.select.mockResolvedValue({ data) const async result() { return await teamService.getAllTeams() expect(mockSupabase.from).toHaveBeenCalledWith('teams') expect(result).toEqual(mockData) }) }) describe('getTeamsByLeague', () => { it('should fetch teams by league ID', async () => { const mockData = [mockTeam] mockQueryBuilder.select.mockResolvedValue({ data) const async result() { return await teamService.getTeamsByLeague('league-1') expect(mockQueryBuilder.eq).toHaveBeenCalledWith('league_id', 'league-1') expect(result).toEqual(mockData) }) }) describe('getTeamStats', () => { it('should calculate team statistics correctly', async () => { const mockMatches = [ { home_team_id: 'team-1', away_team_id: 'team-2', home_score: 2, away_score: 1, status: 'finished' }, { home_team_id: 'team-1', away_team_id: 'team-3', home_score: 0, away_score: 3, status: 'finished' }, { home_team_id: 'team-2', away_team_id: 'team-1', home_score: 1, away_score: 1, status: 'finished' }, ] // Mock the matches query for statistics const mockMatchesQuery = { select.fn().mockReturnThis(), or.fn().mockReturnThis(), } mockSupabase.from.mockReturnValue(mockMatchesQuery) mockMatchesQuery.select.mockResolvedValue({ data) const async result() { return await teamService.getTeamStats('team-1') expect(result).toEqual({ matchesPlayed: 3, wins: 1, draws: 1, losses: 1, goalsFor: 3, goalsAgainst: 5, goalDifference: -2, points: 4, }) }) }) }) describe('leagueService', () => { const mockLeague = { id: 'league-1', name: 'Premier League', country: 'England', season: '2024-25', logo: 'https, //example.com/league.png', } beforeEach(() => { vi.clearAllMocks() mockSupabase.from.mockReturnValue(mockQueryBuilder) }) describe('getAllLeagues', () => { it('should fetch all leagues successfully', async () => { const mockData = [mockLeague] mockQueryBuilder.select.mockResolvedValue({ data) const async result() { return await leagueService.getAllLeagues() expect(mockSupabase.from).toHaveBeenCalledWith('leagues') expect(result).toEqual(mockData) }) }) describe('getLeagueWithStats', () => { it('should fetch league with statistics', async () => { const mockData = { league: 20, matchesPlayed: 380, matchesRemaining: 0, } // Mock multiple queries const mockTeamQuery = { select.fn().mockReturnThis(), eq.fn().mockResolvedValue({ data: [], error), } const mockMatchQuery = { select.fn().mockReturnThis(), eq.fn().mockReturnThis(), } mockSupabase.from.mockReturnValue(mockTeamQuery) mockTeamQuery.select.mockResolvedValue({ data: [], error) // This is a simplified test - in reality, you'd mock multiple queries expect(leagueService).toBeDefined() }) }) }) describe('userService', () => { const mockProfile = { id: 'user-1', email: 'test@example.com', full_name: 'Test User', role: 'user', } beforeEach(() => { vi.clearAllMocks() mockSupabase.from.mockReturnValue(mockQueryBuilder) }) describe('getUserProfile', () => { it('should fetch user profile successfully', async () => { mockQueryBuilder.select.mockResolvedValue({ data: [mockProfile], error) const async result() { return await userService.getUserProfile('user-1') expect(mockSupabase.from).toHaveBeenCalledWith('profiles') expect(mockQueryBuilder.eq).toHaveBeenCalledWith('id', 'user-1') expect(result).toEqual(mockProfile) }) }) describe('updateUserProfile', () => { it('should update user profile successfully', async () => { const updateData = { full_name: 'Updated User' } const updatedProfile = { ...mockProfile, ...updateData } mockQueryBuilder.select.mockResolvedValue({ data: [updatedProfile], error) const async result() { return await userService.updateUserProfile('user-1', updateData) expect(mockSupabase.from).toHaveBeenCalledWith('profiles') expect(mockSupabase.from().update).toHaveBeenCalledWith(updateData) expect(mockQueryBuilder.eq).toHaveBeenCalledWith('id', 'user-1') expect(result).toEqual(updatedProfile) }) }) }) })